#include "UTFR_CAN_TEENSY.hpp"
#include "UTFR_CAN_TEENSY_TYPES.hpp"

#define ARRAY_TO_INT64(array)                                            \
  ((array[0]) | ((uint64_t)array[1] << 8) | ((uint64_t)array[2] << 16) | \
   ((uint64_t)array[3] << 24) | ((uint64_t)array[4] << 32) |             \
   ((uint64_t)array[5] << 40) | ((uint64_t)array[6] << 48) |             \
   ((uint64_t)array[7] << 56))

#define INT64_TO_ARRAY(num, array) \
  do {                             \
    array[0] = num & 0xFF;         \
    array[1] = (num >> 8) & 0xFF;  \
    array[2] = (num >> 16) & 0xFF; \
    array[3] = (num >> 24) & 0xFF; \
    array[4] = (num >> 32) & 0xFF; \
    array[5] = (num >> 40) & 0xFF; \
    array[6] = (num >> 48) & 0xFF; \
    array[7] = (num >> 56) & 0xFF; \
  } while (0)

/*!
 * @brief    Constructor
 *
 * @param[in]    nodeName    Name of the CAN node, primarily used in debug
 * prints
 * @param[in]    busSpeed    Bus speed in unsigned integer form
 * @param[in]    msgArray    Pointer to autogenerated array of messages along
 * with their respective signals
 * @param[in]    rxCallback  Pointer to receive callback function (the function
 * to which received messages will be pushed upon an events() call).
 */
UTFR_TCAN_CLASS
UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::UTFR_CAN_TEENSY(
    String nodeName, int busSpeed, CAN_msg_t *msgArray,
    void (*rxCallback)(const CAN_message_t &)) {
  _nodeName = nodeName;

  if (busSpeed == 100000 || busSpeed == 250000 || busSpeed == 500000 ||
      busSpeed == 1000000)  // check if busSpeed is valid option
  {
    _busSpeed = busSpeed;
  } else {
    _nodeError = CAN_INIT_BUS_SPEED_ERROR;
  }

  _msgArray = msgArray;

  _rxCallback = rxCallback;
}

// Starts node - must be called before any other functions
UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::begin() {
#ifdef CAN_debugMode
  Serial.print("Teensy node ");
  Serial.print(_nodeName);
#endif

  if (!_nodeError) {
    delay(400);  // From FlexCAN_T4 examples

    _node.begin();

    _node.setBaudRate(_busSpeed);

    _node.setMaxMB(RX_MB_COUNT + TX_MB_COUNT);

    for (int i = 0; i < 64; i++)  // Setup mailboxes
    {
      if (i < RX_MB_COUNT) {
        if (i < (int)msg_e::COUNT)  // Avoid indexing out of bounds
        {
          if (_msgArray[i].msg.flags.extended) {
            _node.setMB((FLEXCAN_MAILBOX)i, RX, EXT);
          } else {
            _node.setMB((FLEXCAN_MAILBOX)i, RX, STD);
          }
        } else {
          _node.setMB((FLEXCAN_MAILBOX)i, RX, STD);
        }
        _node.enableMBInterrupt(
            (FLEXCAN_MAILBOX)
                i);  // Rx mailboxes will clear themselves by writing to queue
      }  // which will be pushed to the callback upon calling eventsRx()
      else {
        _node.setMB((FLEXCAN_MAILBOX)i,
                    TX);  // Don't need Tx interrupts unless doing remote
                          // transmission requests
      }
    }

    _node.onReceive(
        _rxCallback);  // Pass receive callback function to FlexCAN_T4

#ifdef CAN_debugMode
    Serial.println(" initialized successfully.");
    _node.mailboxStatus();  // Prints mailbox configuration
#endif
  } else {
#ifdef CAN_debugMode
    Serial.printf(" NOT initialized. Error %d.", _nodeError);
#endif
  }
}

UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::print_errors() {
  CAN_error_t err;
  _node.error(err, true);
  // Serial.printf("Bus status: \n");
  // Serial.println(_node.busStatus());

  // Serial.printf("TX Error Count: \n");
  // Serial.println(_node.errorCountTX());

  // Serial.printf("RX Error Count: \n");
  // Serial.println(_node.errorCountRX());
}

// Distribute messages evenly among mailboxes (not taking message freq into
// account)
UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::setFilters() {
  uint8_t idPerMB =
      (int)msg_e::COUNT / RX_MB_COUNT;  // Find how many IDs to accept with each
                                        // Rx mailbox (quotient)
  idPerMB = (idPerMB == 0) ? 1 : idPerMB;  // Make sure idPerMB isn't 0

  uint8_t extraIds =
      (int)msg_e::COUNT %
      RX_MB_COUNT;  // How many extra IDs do we need to deal with? (remainder)

  _node.setMBFilter(REJECT_ALL);

  for (int i = 0; i < RX_MB_COUNT; i++)  // Set filters
  {
    switch (idPerMB) {
      case 1:
        _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id);

        if (extraIds > 0) {
          _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                            _msgArray[i + RX_MB_COUNT].msg.id);
          extraIds = extraIds - 1;
        }

        break;

      case 2:
        _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                          _msgArray[i + RX_MB_COUNT].msg.id);

        if (extraIds > 0) {
          _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                            _msgArray[i + RX_MB_COUNT].msg.id,
                            _msgArray[i + (2 * RX_MB_COUNT)].msg.id);
          extraIds = extraIds - 1;
        }

        break;

      case 3:
        _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                          _msgArray[i + RX_MB_COUNT].msg.id,
                          _msgArray[i + (2 * RX_MB_COUNT)].msg.id);

        if (extraIds > 0) {
          _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                            _msgArray[i + RX_MB_COUNT].msg.id,
                            _msgArray[i + (2 * RX_MB_COUNT)].msg.id,
                            _msgArray[i + (3 * RX_MB_COUNT)].msg.id);
          extraIds = extraIds - 1;
        }

        break;

      case 4:
        _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                          _msgArray[i + RX_MB_COUNT].msg.id,
                          _msgArray[i + (2 * RX_MB_COUNT)].msg.id,
                          _msgArray[i + (3 * RX_MB_COUNT)].msg.id);

        if (extraIds > 0) {
          _node.setMBFilter((FLEXCAN_MAILBOX)i, _msgArray[i].msg.id,
                            _msgArray[i + RX_MB_COUNT].msg.id,
                            _msgArray[i + (2 * RX_MB_COUNT)].msg.id,
                            _msgArray[i + (3 * RX_MB_COUNT)].msg.id,
                            _msgArray[i + (4 * RX_MB_COUNT)].msg.id);
          extraIds = extraIds - 1;
        }

        break;

      default:
#ifdef CAN_debugMode
        Serial.println("Auto-setting filters failed. Consider using FIFO.");
#endif
        break;
    }
  }

#ifdef CAN_debugMode
  _node.mailboxStatus();
// Serial.println("Filters set successfully.");
#endif
}

// Set masks and filters so that all messages sent by other nodes are received
UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize,
                     _txSize>::setFiltersAcceptAll() {
  _node.setMBFilter(ACCEPT_ALL);
}

// Set masks and filters so that this node receives NO messages
UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize,
                     _txSize>::setFiltersRejectAll() {
  _node.setMBFilter(REJECT_ALL);
}

// Send message by name
UTFR_TCAN_CLASS
int UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::send(msg_e msgName) {
  uint8_t msgIndex = (uint8_t)msgName;
  return _node.write(
      _msgArray[msgIndex]
          .msg);  // Tries to send via Tx mailbox, adds to Tx queue if not
}

/*!
 * @brief    Get signal data by name with scale, offset, and TODO: unit.
 *
 * @param[in]    msgName     Name of message, defined in msgArray
 * @param[in]    signalName  Name of signal, defined at top of
 * UTFR_CAN_TEENSY_TYPES.h
 *
 * @return       int64_t     Signal data
 */
UTFR_TCAN_CLASS
float UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::getSignal(
    msg_e msgName, sig_e signalName) {
  float signalData = (float)getSignalRaw(msgName, signalName);

  uint8_t msgIndex = (uint8_t)msgName;
  uint8_t signalIndex = (uint8_t)signalName;

  float scale = _msgArray[msgIndex].signals[signalIndex].scale;
  float offset = _msgArray[msgIndex].signals[signalIndex].offset;

  signalData = (signalData * scale) + offset;

  return signalData;
}

/*!
 * @brief    Get signal data by name without scale, offset, or units.
 *
 * @param[in]    msgName     Name of message, defined in msgArray
 * @param[in]    signalName  Name of signal, defined at top of
 * UTFR_CAN_TEENSY_TYPES.h
 *
 * @return       uint64_t       Raw signal data
 */
UTFR_TCAN_CLASS
int64_t UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::getSignalRaw(
    msg_e msgName, sig_e signalName) {
  int64_t signalData;
  uint8_t msgIndex = (uint8_t)msgName;  // converting from class enum to integer
  uint8_t signalIndex = (uint8_t)signalName;
  uint8_t startBit = _msgArray[msgIndex].signals[signalIndex].startBit;
  uint8_t sigLength = _msgArray[msgIndex].signals[signalIndex].len;  // bits

  uint64_t mask = 0;
  for (uint8_t i = 0; i < sigLength; i++) {
    mask = (mask << 1) + 1;
  }

  signalData = ARRAY_TO_INT64(_msgArray[msgIndex].msg.buf);
  signalData = signalData >> startBit;
  signalData = signalData & mask;

  return signalData;  // shift back right (the mask is shifted left by startBit
                      // when it's created)
}

/*!
 * @brief    Set signal data by name - pass the SignalData in units of whatever
 * the signal represents. E.g. Setting a temp signal. You could pass in -5.0,
 * the scaling and offset will be taken care of automatically.
 *
 * @param[in]    msgName         Name of message, defined in msgArray
 * @param[in]    signalName      Name of signal, defined at top of
 * UTFR_CAN_TEENSY_TYPES.h
 * @param[in]    signalData      Signed value you wish to set signal to
 *
 * @return       usigned long    Signal data
 */
UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::setSignal(
    msg_e msgName, sig_e signalName, float signalData) {
  uint8_t msgIndex = (uint8_t)msgName;
  uint8_t signalIndex = (uint8_t)signalName;

  float scale = _msgArray[msgIndex].signals[signalIndex].scale;
  float offset = _msgArray[msgIndex].signals[signalIndex].offset;

  int64_t signalRaw = (int64_t)((signalData - offset) / scale);

  setSignalRaw(msgName, signalName, signalRaw);
}

UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::setSignalRaw(
    msg_e msgName, sig_e signalName, int64_t signalData) {
  uint8_t msgIndex = (uint8_t)msgName;
  uint8_t signalIndex = (uint8_t)signalName;
  uint8_t startBit = _msgArray[msgIndex].signals[signalIndex].startBit;
  uint8_t length = _msgArray[msgIndex].signals[signalIndex].len;
  uint8_t startByte = startBit / 8;
  uint8_t endByte = (startBit + length) / 8;
  uint64_t mask = 0;
  uint8_t maskArray[8] = {0, 0, 0, 0, 0, 0, 0, 0};
  uint8_t signalArray[8] = {0, 0, 0, 0, 0, 0, 0, 0};

  for (uint8_t i = 0; i < length; i++) {
    mask = (mask << 1) +
           1;  // Mask has 1s where signal goes in message buffer, 0s otherwise.
  }
  mask = mask << startBit;          // Shift up
  INT64_TO_ARRAY(mask, maskArray);  // Convert to array of bytes

  signalData = signalData << startBit;  // Shift up
  signalData |= ~mask;  // Insert 1s everywhere around the signal
  INT64_TO_ARRAY(signalData, signalArray);  // Convert to array of bytes

  for (uint8_t byte = startByte; byte <= endByte; byte++) {
    _msgArray[msgIndex].msg.buf[byte] |=
        maskArray[byte];  // Write 1s wherever the signal is, leave the data
                          // otherwise
    _msgArray[msgIndex].msg.buf[byte] &= signalArray[byte];
  }
}

// Prints all data stored in a given message (Note: will be in decimal format)
UTFR_TCAN_CLASS
void UTFR_CAN_TEENSY<_bus, msg_e, sig_e, _rxSize, _txSize>::printMsgData(
    msg_e msgName) {
#ifdef CAN_debugMode
  Serial.printf("Message %d data: { ", msgName);

  uint8_t msgIndex = (uint8_t)msgName;

  for (uint8_t dataIdx = 0; dataIdx < 8; dataIdx++) {
    Serial.print(_msgArray[msgIndex].msg.buf[dataIdx]);
    if (dataIdx < 7) {
      Serial.print(" , ");
    }
  }

  Serial.println(" }");
#endif
}

/*!
 *  @brief Sends error over UTFR_CAN node.
 *         Message and Field indexes are found using the error_map_.
 *
 *  @param[in] error Type of error to send, from errorNames_e enum.
 */
/*
void UTFR_CAN_TEENSY::sendError(errorNames_e error)          // TO DO: Update
for Teensy CAN lib
{
    for (uint8_t msgIndex = 0; msgIndex < CAN_MSG_COUNT; msgIndex++) {
        for (uint8_t fieldIndex = 0; fieldIndex < 8; fieldIndex++) {
            if (error_map[msgIndex][fieldIndex] == error) {
                setField(msgIndex, fieldIndex, 0x00);
                sendMsg(msgIndex, 2);
                #ifdef CAN_debugMode
                Serial.print("UTFR_ERROR::sendError: Set Error at Msg Idx ");
                Serial.print(msgIndex);
                Serial.print(" with Field Idx ");
                Serial.print(fieldIndex);
                #endif
                return;
            }
        }
    }
    Serial.print("UTFR_ERROR::sendError: inputted error name not found in error
map");
}*/